import 'package:flutter/material.dart';
import 'package:flutter/widgets.dart';
import 'package:fsc/HomeScreen.dart';

import 'AlgScreen/AffineCipher.dart';
import 'AlgScreen/CaesarCipher.dart';
import 'AlgScreen/DES.dart';
import 'AlgScreen/MonoalphabeticCipher.dart';
import 'AlgScreen/PlayfairCipher.dart';
import 'AlgScreen/RSA.dart';
import 'AlgScreen/SHA1.dart';

class LearnScreen extends StatelessWidget {

  List<dynamic> name=["Caesar cipher Algorithm","Monoalphabetic Cipher Algorithm","Affine Cipher Algorithm","Playfair Cipher Algorithm","SHA1 Algorithm","DES Algorithm", "RSA Algorithm",];
  List<dynamic> explanation=['''هي واحدة من أبسط وأقدم خوارزميات التشفير المعروفة.  يتم تصنيفها ضمن خوارزميات استبدال أحادية الأبجدية (Monoalphabetic Substitution Cipher).

مبدأ عمل خوارزمية تشفير القيصر:

تعتمد الخوارزمية على فكرة تحويل كل حرف في النص الأصلي (الرسالة قبل التشفير) إلى حرف آخر يبعد عنه بعدًا محددًا في ترتيب الأبجدية العربية.
يتم استخدام مفتاح تحويل (Shift Key) وهو عبارة عن رقم صحيح يحدد عدد المناصب التي يتم تحويل كل حرف بواسطتها.
على سبيل المثال، إذا كان مفتاح التحويل هو 3، فإنه يتم تحويل حرف "ا" إلى حرف "د" (ببعد 3 أحرف في الأبجدية).
مثال:

لنفترض أن النص الأصلي هو "مرحبا" ( مرحبا ) و مفتاح التحويل هو 2.
طبقًا للخوارزمية، يتم تحويل كل حرف إلى حرف يبعد عنه حرفين في الترتيب:
حرف "م" إلى "ص" (ص)
حرف "ر" إلى "ش" (ش)
حرف "ح" إلى "خ" (خ)
حرف "ب" إلى "د" (د)
حرف "ا" إلى "ج" (ج)
النص المشفر النهائي سيكون "صشخدخج" (صشخدخج).
فك تشفير رسالة مشفرة باستخدام خوارزمية تشفير القيصر:

عملية فك التشفير هي عكس عملية التشفير. بمعرفة مفتاح التحويل، يتم تحويل كل حرف مشفر إلى موضع يبعد عنه المفتاح نفسه في ترتيب الأبجدية بالعكس.

مميزات وعيوب خوارزمية تشفير القيصر:

المميزات:

بسيطة وسهلة الفهم والتطبيق.
العيوب:

غير آمنة: تعتبر خوارزمية ضعيفة جدا وغير آمنة للاتصالات السرية.
سهولة كسر الشفرة: بسبب بساطة الخوارزمية وقصر طول مفتاح التحويل (عادة ما يكون رقمًا صغيرًا)، يسهل كسر شفرة النص المشفر باستخدام تحليل التكرار (Frequency Analysis) حيث يتم تحديد أكثر الأحرف شيوعًا في النص المشفر ومن ثم معرفة الحرف الذي يقابله في النص الأصلي.
استخدامات:

تستخدم حاليًا بشكل تعليمي لفهم المفاهيم الأساسية للتشفير.
قد تستخدم في العاب تشفير بسيطة للأطفال.''','''  هي خوارزمية تشفير بسيطة تعتمد على استبدال كل حرف في النص الأصلي (الرسالة قبل التشفير) بحرف آخر وفقا لقاعدة محددة.

بمعنى آخر، يتم إنشاء مُعَقِّم (Mapping) يربط كل حرف بحرف آخر مختلف. على سبيل المثال، يمكن استبدال حرف "ا" بحرف "س" دائما، بغض النظر عن مكانه في النص.

تشفير وفك التشفير:

التشفير: يتم استبدال كل حرف في النص الأصلي بالحرف المقابل له في المُعَقِّم.
فك التشفير: يتم استبدال كل حرف مشفر بالحرف الذي يقابله في المُعَقِّم ولكن بشكل عكسي.
مميزات وعيوب خوارزمية التشفير أحادية الأبجدية:

المميزات:

بسيطة وسهلة الفهم والتطبيق.
العيوب:

غير آمنة: يسهل كسر شفرتها وذلك بسبب تكرر ظهور بعض الأحرف في اللغة العربية مثل حرف الراء الذي يعتبر أكثر الأحرف شيوعا. بمجرد تحديد أكثر الأحرف شيوعا في النص المشفر، يمكن معرفة الحرف الذي يقابله في النص الأصلي وبالتالي كسر الشفرة.
لا توفر سرية عالية: بمجرد معرفة قاعدة الاستبدال المستخدمة، يمكن فك تشفير أي رسالة مشفرة باستخدام نفس القاعدة.
استخدامات:

تستخدم حاليا بشكل تعليمي لفهم مفاهيم التشفير الأساسية.
قد تستخدم في العاب تشفير بسيطة للأطفال.
                ''', '''هي خوارزمية تشفير أحادية البديل (Monoalphabetic Cipher) بسيطة أخرى تعتمد على استبدال كل حرف في النص الأصلي بحرف آخر وفقا لقاعدة محددة. لكنها تختلف عن خوارزمية أحادية البديل التقليدية بأنها تستخدم معادلة رياضية بسيطة لإجراء عملية الاستبدال.

عملية التشفير وفك التشفير:

المعادلة:  تعتمد خوارزمية التشفير التابعة على معادلة رياضية من الشكل Y = (aX + b) mod m, حيث:

X: يمثل الرمز في النص الأصلي.
Y: يمثل الرمز المقابل له في النص المشفر.
a: عدد صحيح ثابت يُسمى عامل الضرب (multiplier).
b: عدد صحيح ثابت يُسمى عامل الإزاحة (shift).
mod m: عملية modulo التي تأخذ الباقي عند قسمة (aX + b) على عدد صحيح موجب m يُسمى بالحجم الأبجدي (alphabet size).
التشفير: يتم حساب قيمة Y لكل حرف في النص الأصلي باستخدام المعادلة أعلاه.

فك التشفير: نقوم بعكس عملية التشفير باستخدام معادلة أخرى يمكن اشتقاقها من المعادلة الأولى.

مثال:

لنفترض أننا نريد تشفير كلمة "سر" باستخدام خوارزمية التشفير التابعة مع عامل ضرب (a) يساوي 3 وعامل إزاحة (b) يساوي 1، وحيث أن حجم الأبجدية العربية هو 28 حرف (من الألف إلى الياء).

حرف الراء (ر) يظهر في المرتبة 18.
عملية التشفير: Y = (3 * 18 + 1) mod 28 = 55 mod 28 = 27
حرف القاف (ق) يظهر في المرتبة 27، which is our encrypted character.
مميزات وعيوب خوارزمية التشفير التابعة:

المميزات:

بسيطة وسهلة الفهم والتطبيق.
العيوب:

غير آمنة: مثل خوارزمية أحادية البديل التقليدية، تعتمد على استبدال حرف بحرف مما يجعلها غير آمنة ويمكن كسر شفرتها بسهولة باستخدام تحليل التكرار الحرفي في اللغة العربية.
لا توفر سرية عالية: يسهل معرفة قاعدة الاستبدال المستخدمة وكسر شفرة أي رسالة مشفرة.
استخدامات:

تستخدم حاليا بشكل تعليمي لفهم مفاهيم التشفير الأساسية.
قد تستخدم في العاب تشفير بسيطة للأطفال''','''خوارزمية تشفير بلي فير (Playfair Cipher) هي خوارمية تشفير كلاسيكية تعتمد على استبدال زوجين من الأحرف بدلا من حرف واحد.

المكونات الأساسية:

مصفوفة 5 * 5: يتم إنشاء مصفوفة 5 * 5 تحتوي على جميع أحرف الأبجدية العربية (باستثناء حرف ال التعريف "ال")، ويمكن ترتيب الأحرف بشكل عشوائي أو وفقا لكلمة مفتاح سرية.
كلمة مفتاح سرية (اختياري): تستخدم كلمة سرية لتعديل مصفوفة 5 * 5 بحيث يتم استبعاد الأحرف المكررة واستبدالها بأحرف أخرى.
خطوات التشفير:

تحضير النص:

تتم إزالة أي فراغات أو علامات ترقيم من النص الأصلي.
في حال وجود حرفين متكررين بجوار بعضهما، يتم وضع حرف فاصل (مثل "X") بينهما.
استبدال زوجي الأحرف:

يتم تقسيم النص إلى أزواج من الأحرف.
إذا كان الزوج مكونا من حرف واحد فقط، يضاف حرف فاصل (مثل "X") بعده.
يتم استبدال كل زوج من الأحرف وفقا لموقعهما في مصفوفة 5 * 5:
إذا كان الحرفين في نفس الصف، يتم استبدال كل حرف بالحرف الذي يليه في نفس الصف.
إذا كان الحرفين في نفس العمود، يتم استبدال كل حرف بالحرف الذي يقع أسفل منه في نفس العمود.
إذا تواجد كل حرف من الزوج في مربع مختلف، يتم استبدال كل حرف بالحرف الموجود في نفس الصف للآخر والحرف الموجود في نفس العمود للآخر.
الحصول على النص المشفر:

يتم دمج الأحرف المستبدلة لتكوين النص المشفر.
خطوات فك التشفير:

عملية فك التشفير تتبع نفس الخطوات ولكن يتم استبدال الأحرف المشفرة وفقا لموقعها العكسي في مصفوفة 5 * 5.

مميزات وعيوب خوارزمية تشفير بلي فير:

المميزات:

أكثر تعقيدا من خوارزميات الاستبدال الأحرفية البسيطة.
صعوبة أكبر في كسر الشفرة.
العيوب:

أقل أمانا من خوارزميات التشفير الحديثة.
عملية التشفير وفك التشفير يمكن أن تكون مملة بالنسبة للنصوص الطويلة.
استخدامات:

تستخدم حاليا بشكل تعليمي لفهم مفاهيم التشفير الأساسية.
قد تستخدم في العاب تشفير أكثر تعقيدا من ألعاب الاستبدال الأحرفية البسيطة.''','''هي دالة تجزئة تُستخدم لإنشاء بصمة رقمية فريدة لأيّة بيانات إدخال. فكّر بالبصمة الرقمية كبصمة إصبع الإنسان، فريدة لكل عنصر.

تعمل خوارزمية SHA-1 على معالجة أيّة بيانات إدخال، بغض النظر عن حجمها، وتنتج قيمة تجزئة ثابتة الطول مكونة من 160 بت (20 بايت) تُكتب عادةً برمز سداسي عشري مكون من 40 حرفًا.

مميزات خوارزمية SHA-1:

تنتج بصمة فريدة: أي تغيير بسيط في البيانات الإدخال سيؤدي إلى اختلاف كبير في قيمة التجزئة.
سهلة الاستخدام: يمكن حساب قيمة التجزئة لأيّة بيانات إدخال بشكل سريع وفعال.
كانت آمنة لفترة طويلة: لطول فترة، اعتبرت خوارزمية SHA-1 آمنة للاستخدام في العديد من التطبيقات.
عيوب خوارزمية SHA-1:

ضعف أمني حديث: في الآونة الأخيرة، تم اكتشاف نقاط ضعف أمنية في خوارزمية SHA-1، مما يجعلها غير آمنة للاستخدام في تطبيقات حساسة.
لا يُنصح باستخدامها حاليًا: بسبب اكتشاف نقاط الضعف الأمنية، لا يُنصح باستخدام خوارزمية SHA-1 في تطبيقات جديدة تتطلب مستوى عالٍ من الأمان.
استخدامات سابقة لخوارزمية SHA-1:

التحقق من سلامة الملفات: للتأكد من عدم تغيير الملف أثناء النقل أو التخزين.
التحكم بالوصول: للتحقق من صحة كلمات السر.
التوقيع الإلكتروني: للمصادقة على صحة المستندات الرقمية''','''هي خوارزمية تشفير كتلة متماثل المفتاح تم تطويرها في السبعينيات من قبل المعهد الوطني الأمريكي للمعايير والتكنولوجيا (NIST). كانت في وقت ما الخوارزمية الموحدة والمقبولة على نطاق واسع لتشفير البيانات الرقمية الآمن.

خصائص خوارزمية DES:

تشفير كتلة: تقوم بتشفير البيانات على شكل كتل ثابتة الحجم (64 بت في DES).
مفتاح متماثل: تستخدم نفس المفتاح السرّي لكل من عملية التشفير وفك التشفير.
طول المفتاح: يبلغ طول المفتاح في DES‏ 64 بت، ولكن فعلياً يتم استخدام 56 بت فقط للتشفير، بينما تستخدم 8 بتات للتدقيق بالتماثل (Parity Check).
ملاحظات حول DES:

على الرغم من دورها التاريخي المهم، يُعتبر DES حاليًا غير آمن للاستخدام في التطبيقات الحساسة بسبب قصر طول المفتاح (56 بت). أصبحت خوارزميات حديثة مثل AES أكثر شيوعا وذلك بسبب أطوال مفاتيحها الأكبر (128 أو 256 بت).
لعبت خوارزمية DES دورًا رئيسيًا في تطوير علم التشفير الحديث وساهمت في زيادة الاهتمام العام بأهمية تشفير البيانات.
استخدامات DES الحالية:

تستخدم أحيانًا في تطبيقات تراثية التي لا تتطلب مستوى عالٍ من الأمان.
تستخدم لأغراض تعليمية لفهم مفاهيم التشفير الأساسية.''','''خوارزمية RSA (اختصار لـ Rivest-Shamir-Adleman) هي خوارزمية تشفير بمفتاح عام (Asymmetric) تُستخدم على نطاقٍ واسعٍ لحماية البيانات.

في أنظمة التشفير بمفتاح عام، يكون هناك مفتاحان مختلفان:

المفتاح العام (Public Key): يكون متاحًا للجميع ويمكن استخدامه لتشفير البيانات.
المفتاح الخاص (Private Key): سري للغاية ويحتفظ به المستخدم وحده، ويُستخدم لفك تشفير البيانات التي تم تشفيرها باستخدام المفتاح العام.
تكمن قوة خوارزمية RSA في صعوبة استنتاج المفتاح الخاص حتى لو كان المفتاح العام معلوماً للجميع.

مراحل استخدام خوارزمية RSA:

إنشاء المفاتيح:

يقوم المستخدم بعملية حسابية خاصة تولد مفتاحين، أحدهما عام والآخر خاص.
يتم نشر المفتاح العام للجميع، بينما يُحفظ المفتاح الخاص بشكل سري للغاية.
التشفير:

يرسل المرسل رسالته إلى المستقبل.
يقوم المرسل باستخدام المفتاح العام للمستقبل لتشفير الرسالة.
لا يمكن فك تشفير الرسالة المشفرة إلا باستخدام المفتاح الخاص للمستقبل.
فك التشفير:

يتلقى المستقبل الرسالة المشفرة.
يستخدم المستقبل المفتاح الخاص الخاص به لفك تشفير الرسالة واستعادة الرسالة الأصلية.
استخدامات خوارزمية RSA:

تُستخدم خوارزمية RSA على نطاق واسع في التطبيقات التي تتطلب تبادل آمن للبيانات، مثل التجارة الإلكترونية والخدمات المصرفية عبر الإنترنت.
تُستخدم أيضًا في التوقيع الرقمي للوثائق الإلكترونية للتأكد من صحة وسلامة المستندات.
مميزات خوارزمية RSA:

الأمان: صعوبة فك تشفير البيانات المشفرة باستخدام RSA تجعلها خوارزمية تشفير آمنة للغاية.
التوقيع الرقمي: تتيح RSA التحقق من صحة وسلامة المستندات الإلكترونية.
عيوب خوارزمية RSA:

البطء: تعتبر خوارزمية RSA بطيئة نسبيا مقارنة بأنواع أخرى من خوارزميات التشفير.
قوة المعالجة: تتطلب خوارزمية RSA قدرة معالجة عالية، مما يجعلها غير مناسبة لبعض الأجهزة ذات الإمكانيات المحدودة.''',];
   LearnScreen({super.key});

  @override
  Widget build(BuildContext context) {
    return SafeArea(
        child: Scaffold(
      appBar: AppBar(
        title: Text(
          "تعلم",
          style: TextStyle(color: Colors.indigo.shade600),


        ),
        actions: [IconButton(onPressed: (){
          Navigator.pushReplacement(context, MaterialPageRoute(builder: (context) => HomeScreen()));
        }, icon: Icon(Icons.home))],
        elevation: 2,
        centerTitle: true,
        backgroundColor: Colors.white,
      ),
      body:ListView(
        children: [
          Directionality(
            textDirection: TextDirection.rtl,
            child: Container(
              child: Text(
                name[numberOfAlgorithm],
                style: TextStyle(color: Colors.deepPurple.shade900),
                textAlign: TextAlign.center,
              ),
              padding: EdgeInsetsDirectional.all(8),
              margin: EdgeInsetsDirectional.all(8),
              decoration: BoxDecoration(
                  borderRadius: BorderRadius.circular(15), color: Colors.white),
            ),
          ),
          SizedBox(
            height: 10,
          ),
          Directionality(
            textDirection: TextDirection.rtl,
            child: Container(
              child: Text(
                explanation[numberOfAlgorithm],
                style: TextStyle(color: Colors.deepPurple.shade900),
                textAlign: TextAlign.start,
              ),
              padding: EdgeInsetsDirectional.all(8),
              margin: EdgeInsetsDirectional.all(8),
              decoration: BoxDecoration(
                  borderRadius: BorderRadius.circular(15), color: Colors.white),
            ),
          ),
          SizedBox(
            height: 20,
          ),
          Padding(
            padding: const EdgeInsets.all(16.0),
            child: ElevatedButton(
              onPressed: () {
                switch (numberOfAlgorithm) {
                // Code to execute if expression equals value1
                  case 0:
                    Navigator.push(
                      context,
                      MaterialPageRoute(builder: (context) => const CaesarCipherAlgorithmScreen()),
                    );
                    break;
                  case 1:
                  // Code to execute if expression equals value2
                    Navigator.push(
                      context,
                      MaterialPageRoute(builder: (context) => const MonoalphabeticCipherAlgorithmScreen()),
                    );
                    break;
                    case 2:
                  // Code to execute if expression equals value2
                    Navigator.push(
                      context,
                      MaterialPageRoute(builder: (context) => const AffineCipherAlgorithmScreen()),
                    );
                    break;
                    case 3:
                  // Code to execute if expression equals value3
                    Navigator.push(
                      context,
                      MaterialPageRoute(builder: (context) => const PlayfairCipherAlgorithmScreen()),
                    );
                    break;
                    case 4:
                  // Code to execute if expression equals value4
                    Navigator.push(
                      context,
                      MaterialPageRoute(builder: (context) => const SHA1AlgorithmScreen()),
                    );
                    break;
                    case 5:
                  // Code to execute if expression equals value4
                    Navigator.push(
                      context,
                      MaterialPageRoute(builder: (context) => const DESAlgorithmScreen()),
                    );
                    break;
                    case 6:
                  // Code to execute if expression equals value4
                    Navigator.push(
                      context,
                      MaterialPageRoute(builder: (context) => const RSAAlgorithmScreen()),
                    );
                    break;
                  default:
                  //  Navigator.push(
                  //    context,
               //       MaterialPageRoute(builder: (context) => const UsedAlgorithmScreen()),
               //     );
                  // Code to execute if no case matches
                }

              },
              child: const Text('Used Algorithm'),
            ),
          ),
        ],
      ),
      backgroundColor: Colors.deepPurple.shade900,
    ));
  }
}
